/// @docImport 'dart:async';
library;

import 'package:analyzer/dart/element/element2.dart';
import 'package:build/build.dart';
import 'package:meta/meta.dart';
import 'package:source_gen/source_gen.dart';

/// A generator abstraction that helps to generate multiple components
/// into a single output file.
///
/// Override the [generateComponents] method to define how to generate,
/// and override the [joinComponents] method to define how to compose,
/// instead of overriding the ordinary [generate] method.
abstract class ComposedGenerator extends DirectGenerator {
  const ComposedGenerator();

  /// Define how to generate from a [library].
  ///
  /// 1. Return `null` to indicate there's nothing to generate.
  /// 2. When the returned value is not null, it will generate such file.
  /// 3. This method is just a shell for encapsulation.
  /// 4. It's strongly not recommended to override this method:
  /// consider overriding [generateComponents] and [joinComponents] instead.
  @override
  String? generate(LibraryReader library, BuildStep buildStep) {
    final Iterable<String> results = generateComponents(library, buildStep);
    return results.isEmpty ? null : joinComponents(results, library, buildStep);
  }

  /// Define how to join results generated by each annotation.
  @protected
  String joinComponents(
    Iterable<String> results,
    LibraryReader library,
    BuildStep buildStep,
  ) => results.join('\n\n');

  /// How to generate all components inside according to current library.
  ///
  /// The return value of this method is supposed to be
  /// an iterable strings of all generated components,
  /// and an empty iterable indicates there's nothing to generate.
  ///
  /// This method is an encapsulation over the [generate] method,
  /// which will be called by the builder,
  /// and the [joinComponents] method helps to define
  /// how to join all generated components.
  @protected
  Iterable<String> generateComponents(
    LibraryReader library,
    BuildStep buildStep,
  );
}

abstract class RecursiveGenerator extends ComposedGenerator {
  const RecursiveGenerator();

  /// Define how to generate a single element in the AST.
  ///
  /// All elements in the AST will be visited, which might cost a lot,
  /// so it's supposed to return `null` when necessary as soon as possible
  /// to tell the recursive visitor to skip redundant steps.
  String? generateElement(Element2 element);

  /// Visit all elements recursively and generate when necessary.
  @override
  Iterable<String> generateComponents(
    LibraryReader library,
    BuildStep buildStep,
  ) => _generateComponents(library.element);

  /// Recursive encapsulation of generating a single layer of element in AST.
  Iterable<String> _generateComponents(Element2 element) sync* {
    for (final Element2 element in element.children2) {
      final String? result = generateElement(element);
      if (result != null) yield result;
      yield* _generateComponents(element);
    }
  }
}

/// A generator that avoid any future operations.
///
/// Future operations, and corresponding wrapping over [FutureOr],
/// might slow down the generating process, especially in recursive cases,
/// and it's not commonly used.
/// This abstract class constrain the return type of [generate] method
/// to avoid future operations in all its descendants,
/// which will also simplify the further implementations.
abstract class DirectGenerator extends Generator {
  const DirectGenerator();

  /// Generates Dart code for an input Dart library.
  ///
  /// When returning `null`, it means there's nothing to generate,
  /// and it will not create corresponding output file.
  /// Otherwise, the generated file will be created.
  @override
  String? generate(LibraryReader library, BuildStep buildStep);
}

/// Generator that output a part file with `part of` prefix.
mixin PartGenerator on DirectGenerator {
  /// Add part of statement as the prefix of the generated result if necessary.
  @override
  String? generate(LibraryReader library, BuildStep buildStep) {
    final String? result = super.generate(library, buildStep);
    return result == null ? null : '${generatePartOf(buildStep)}\n\n$result';
  }

  /// Generate part of statement according to current [buildStep].
  String generatePartOf(BuildStep buildStep) {
    return "part of '${buildStep.inputId.pathSegments.last}';";
  }
}
